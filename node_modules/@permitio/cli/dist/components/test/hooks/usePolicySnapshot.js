import { useRolesApi } from '../../../hooks/useRolesApi.js';
import { useTenantApi, } from '../../../hooks/useTenantApi.js';
import { useResourcesApi, } from '../../../hooks/useResourcesApi.js';
import { useCallback, useEffect, useRef, useState } from 'react';
import randomName from '@scaleway/random-name';
import { useUserApi } from '../../../hooks/useUserApi.js';
import { saveFile } from '../../../utils/fileSaver.js';
export const useGeneratePolicySnapshot = ({ dryRun, models, path, isTestTenant = true, }) => {
    const { getRoles } = useRolesApi();
    const { createTenant } = useTenantApi();
    const { getResources } = useResourcesApi();
    const { createUser } = useUserApi();
    const [roles, setRoles] = useState([]);
    const [error, setError] = useState(null);
    const [state, setState] = useState('roles');
    const [tenantId, setTenantId] = useState(undefined);
    const [modelsGenerated, setModelsGenerated] = useState(0);
    const [finalConfig, setFinalConfig] = useState([]);
    const resourcesRef = useRef([]);
    const [dryUsers, setDryUsers] = useState([]);
    const generatedUsersRBACRef = useRef([]);
    const userRoleMappingRBACRef = useRef({});
    const [createdUsers, setCreatedUsers] = useState([]);
    const buildUserInfoFromUsername = useCallback((user) => {
        const [firstName = '', lastName = ''] = user.split(' ');
        return {
            key: firstName + lastName,
            email: firstName + lastName + '@gmail.com',
            firstName,
            lastName,
        };
    }, []);
    const createDryUsers = useCallback((usernames, userRoleMappings) => {
        const result = [];
        for (const user of usernames) {
            const { key, email, firstName, lastName } = buildUserInfoFromUsername(user);
            const dryUser = {
                key: key,
                firstName: firstName,
                lastName: lastName,
                email: email,
                roles: userRoleMappings[user]?.map(role => role.key) ?? [],
            };
            result.push(dryUser);
        }
        setDryUsers(result);
        // eslint-disable-next-line sonarjs/no-duplicate-string
        setState('rbac-generate');
    }, [buildUserInfoFromUsername]);
    const createUserAndAttachRoles = useCallback(async (usernames, userRoleMappings) => {
        if (usernames.length === 0) {
            setState('rbac-generate');
            return;
        }
        try {
            for (const user of usernames) {
                const { key, email, firstName, lastName } = buildUserInfoFromUsername(user);
                const roles = userRoleMappings[user] || [];
                const body = {
                    key: key,
                    first_name: firstName,
                    last_name: lastName,
                    email: email,
                    attributes: {},
                    role_assignments: roles.map(role => ({
                        role: role.key,
                        tenant: tenantId || 'default',
                    })),
                };
                const result = await createUser(body);
                if (result.error) {
                    setError(result.error);
                    return;
                }
                setCreatedUsers(prev => [
                    ...prev,
                    {
                        key: body.key,
                        email: body.email ?? '',
                        firstName: body.first_name ?? ' ',
                        lastName: body.last_name ?? ' ',
                        roles: body.role_assignments?.map(role => role.role) ?? [],
                    },
                ]);
            }
            setState('rbac-generate');
        }
        catch (err) {
            setError(err instanceof Error ? err.message : String(err));
        }
    }, [buildUserInfoFromUsername, createUser, tenantId]);
    const fetchRoles = useCallback(async () => {
        let { data, error } = await getRoles();
        if (error || data === undefined) {
            setError(error);
            return;
        }
        data = data;
        if (data.length === 0) {
            setError('Environment has no Roles present');
            return;
        }
        setRoles(data);
        setState('rbac-tenant');
    }, [getRoles]);
    const fetchResources = useCallback(async () => {
        const { data, error } = await getResources();
        if (error) {
            setError(error);
            return;
        }
        resourcesRef.current = data;
        setState('rbac-users');
    }, [getResources]);
    const createNewTenant = useCallback(async () => {
        if (!isTestTenant) {
            setTenantId('default');
            setState('resources');
            return;
        }
        const name = 'test-tenant-' + randomName('', '');
        setTenantId(name);
        const body = {
            key: name,
            name: name,
            description: 'This is a tenant created by permit-cli for creating test users',
            attributes: {},
        };
        const { error } = await createTenant(body);
        if (error) {
            setError(error);
            return;
        }
        setState('resources');
    }, [createTenant, isTestTenant]);
    const generateRBACConfig = useCallback(() => {
        const config = generatedUsersRBACRef.current.flatMap(user => resourcesRef.current.flatMap(resource => Object.entries(resource.actions).flatMap(([, action]) => {
            let result = false;
            userRoleMappingRBACRef.current[user]?.forEach(role => {
                result || (result = role.permissions?.includes(`${resource.key}:${action.key}`) ??
                    false);
            });
            const { key } = buildUserInfoFromUsername(user);
            return {
                user: key,
                action: action.key ?? '',
                resource: { type: resource.key, tenant: tenantId ?? '' },
                result: result,
            };
        })));
        setFinalConfig(prev => [...prev, ...config]);
        setModelsGenerated(prev => prev + 1);
    }, [buildUserInfoFromUsername, tenantId]);
    const saveConfigToPath = useCallback(async () => {
        // Write config as pretty JSON
        const json = JSON.stringify(dryRun
            ? { users: dryUsers, config: finalConfig }
            : { config: finalConfig }, null, 2);
        const { error } = await saveFile(path ?? '', json);
        if (error) {
            setError(error);
            return;
        }
        setState('done');
    }, [dryRun, dryUsers, finalConfig, path]);
    const generateUsersAndRoleMapping = useCallback(() => {
        let generatedUsers = [];
        const userRoleMappingRBAC = {};
        const userNoAccess = randomName('', ' ');
        generatedUsers.push(userNoAccess);
        userRoleMappingRBAC[userNoAccess] = [];
        roles.forEach(role => {
            const userAllAccess = randomName('', ' ');
            generatedUsers.push(userAllAccess);
            userRoleMappingRBAC[userAllAccess] = [role];
        });
        generatedUsersRBACRef.current = [
            ...generatedUsersRBACRef.current,
            ...generatedUsers,
        ];
        userRoleMappingRBACRef.current = userRoleMappingRBAC;
        return { generatedUsers, userRoleMappingRBAC };
    }, [roles]);
    // Check if we have generated all config.
    useEffect(() => {
        if (modelsGenerated === models.length) {
            if (!path) {
                setTimeout(() => {
                    setState('done');
                }, 1000);
            }
            else {
                saveConfigToPath();
            }
        }
    }, [models, modelsGenerated, path, saveConfigToPath]);
    // Step 1 : Get all roles and resources
    useEffect(() => {
        if (!models.includes('RBAC'))
            return;
        if (roles.length === 0 && state === 'roles') {
            fetchRoles();
        }
        else if (tenantId === undefined && state === 'rbac-tenant') {
            createNewTenant();
        }
        else if (resourcesRef.current.length === 0 && state === 'resources') {
            fetchResources();
        }
        else if (generatedUsersRBACRef.current.length === 0 &&
            state === 'rbac-users') {
            const { generatedUsers, userRoleMappingRBAC } = generateUsersAndRoleMapping();
            if (dryRun) {
                createDryUsers(generatedUsers, userRoleMappingRBAC);
            }
            else {
                createUserAndAttachRoles(generatedUsers, userRoleMappingRBAC);
            }
        }
        else if (state === 'rbac-generate') {
            generateRBACConfig();
        }
    }, [
        createNewTenant,
        createDryUsers,
        createUserAndAttachRoles,
        dryRun,
        fetchResources,
        fetchRoles,
        generateRBACConfig,
        generateUsersAndRoleMapping,
        models,
        roles.length,
        state,
        tenantId,
    ]);
    return {
        state,
        error,
        roles,
        tenantId,
        finalConfig,
        dryUsers,
        createdUsers,
    };
};
