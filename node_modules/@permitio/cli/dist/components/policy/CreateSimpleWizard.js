import React, { useState, useEffect, useCallback } from 'react';
import { Box, Text } from 'ink';
import { ResourceInput } from './ResourceInput.js';
import { ActionInput } from './ActionsInput.js';
import { RoleInput } from './RoleInput.js';
import { useResourcesApi } from '../../hooks/useResourcesApi.js';
import { useRolesApi } from '../../hooks/useRolesApi.js';
import { useParseResources } from '../../hooks/useParseResources.js';
import { useParseActions } from '../../hooks/useParseActions.js';
import { useParseRoles } from '../../hooks/useParseRoles.js';
export default function CreateSimpleWizard({ presentResources, presentActions, presentRoles, onComplete, onError, }) {
    // Parse preset values
    const parsedResources = useParseResources(presentResources);
    const parsedActions = useParseActions(presentActions);
    const parsedRoles = useParseRoles(presentRoles);
    // Initialize step based on preset values
    const getInitialStep = () => {
        if (presentResources && presentActions && presentRoles)
            return 'complete';
        if (presentResources && presentActions)
            return 'roles';
        if (presentResources)
            return 'actions';
        return 'resources';
    };
    const [step, setStep] = useState(getInitialStep());
    const [resources, setResources] = useState(parsedResources);
    const [actions, setActions] = useState(parsedActions);
    const [error, setError] = useState(null);
    const [status, setStatus] = useState(presentResources && presentActions && presentRoles ? 'processing' : 'idle');
    const { createBulkResources } = useResourcesApi();
    const { createBulkRoles } = useRolesApi();
    // Handle preset data processing
    // Handle completion or error states
    useEffect(() => {
        if (status === 'error') {
            if (onError) {
                onError(error || 'An unknown error occurred');
            }
            else {
                process.exit(1);
            }
        }
        if (status === 'success') {
            if (onComplete) {
                onComplete(resources[0]?.key || '', Object.keys(actions)[0] || '');
            }
            else {
                process.exit(0);
            }
        }
    }, [status, error, resources, actions, onComplete, onError]);
    const handleError = useCallback((error) => {
        setError(error);
        setStatus('error');
    }, []);
    const handleResourcesComplete = (resourceList) => {
        try {
            setResources(resourceList);
            setStep('actions');
        }
        catch (err) {
            handleError(`Failed to process resources: ${err.message}`);
        }
    };
    const handleActionsComplete = (actionDefs) => {
        try {
            setActions(actionDefs);
            const updatedResources = resources.map(resource => ({
                ...resource,
                actions: actionDefs,
            }));
            setResources(updatedResources);
            setStep('roles');
        }
        catch (err) {
            handleError(`Failed to process actions: ${err.message}`);
        }
    };
    const handleRolesComplete = useCallback(async (roles) => {
        setStatus('processing');
        try {
            await createBulkResources(resources);
            await createBulkRoles(roles);
            setStatus('success');
            setResources([]);
        }
        catch (err) {
            handleError(`Failed to create policy: ${err.message}`);
            setResources([]);
        }
    }, [createBulkResources, createBulkRoles, resources, handleError]);
    useEffect(() => {
        const processPresetData = async () => {
            if (presentResources && presentActions && presentRoles) {
                try {
                    const resourcesWithActions = parsedResources.map(resource => ({
                        ...resource,
                        actions: parsedActions,
                    }));
                    setResources(resourcesWithActions);
                    await handleRolesComplete(parsedRoles);
                }
                catch (err) {
                    handleError(err.message);
                }
            }
            else if (presentResources && presentActions) {
                const resourcesWithActions = parsedResources.map(resource => ({
                    ...resource,
                    actions: parsedActions,
                }));
                setResources(resourcesWithActions);
            }
        };
        processPresetData();
    }, [
        presentResources,
        presentActions,
        presentRoles,
        parsedResources,
        parsedActions,
        parsedRoles,
        handleRolesComplete,
        handleError,
    ]);
    return (React.createElement(Box, { flexDirection: "column", padding: 1 },
        status === 'processing' && React.createElement(Text, null, "Processing your request..."),
        status === 'error' && !onError && (React.createElement(Box, { flexDirection: "column" },
            React.createElement(Text, { color: "red" },
                "[Error] ",
                error))),
        status === 'success' && (React.createElement(Box, { flexDirection: "column" },
            React.createElement(Text, { color: "green" }, "[Success] Policy table created successfully"))),
        status === 'idle' && (React.createElement(React.Fragment, null,
            step === 'resources' && !presentResources && (React.createElement(ResourceInput, { onComplete: handleResourcesComplete })),
            step === 'actions' && !presentActions && (React.createElement(ActionInput, { onComplete: handleActionsComplete, availableResources: resources.map(r => r.key) })),
            step === 'roles' && !presentRoles && (React.createElement(RoleInput, { availableActions: Object.keys(actions), onComplete: handleRolesComplete, availableResources: resources.map(r => r.key) }))))));
}
