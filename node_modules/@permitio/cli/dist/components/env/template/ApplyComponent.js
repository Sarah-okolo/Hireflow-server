import React, { useState, useCallback, useEffect } from 'react';
import { getFiles, ApplyTemplate, ApplyTemplateLocally, getResourceAndAction, } from '../../../lib/env/template/utils.js';
import SelectInput from 'ink-select-input';
import { Text, Box } from 'ink';
import Spinner from 'ink-spinner';
import { useAuth } from '../../AuthProvider.js';
export default function ApplyComponent({ local, template, onComplete, onError, }) {
    const [errorMessage, setErrorMessage] = useState('');
    const [successMessage, setSuccessMessage] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [showContinue, setShowContinue] = useState(false);
    const files = getFiles();
    const { authToken: key } = useAuth();
    const [resource, setResource] = useState(null);
    const [action, setAction] = useState(null);
    const selectionValues = files.map(file => ({
        label: file,
        value: file,
    }));
    // Modified to handle errors immediately but success with Continue button
    useEffect(() => {
        if (errorMessage) {
            if (onError)
                onError(errorMessage);
            else {
                setTimeout(() => {
                    process.exit(1);
                }, 500);
            }
        }
        if (successMessage && !onComplete) {
            setTimeout(() => {
                process.exit(0);
            }, 500);
        }
        // Don't automatically call onComplete - we'll do it when Continue is pressed
    }, [errorMessage, onError, successMessage, onComplete]);
    const handleContinue = useCallback(() => {
        if (onComplete && resource && action) {
            onComplete(resource, action);
        }
    }, [onComplete, resource, action]);
    // Memoized function to apply template
    const applyTemplate = useCallback(async (selectedTemplate) => {
        setIsLoading(true);
        const { resource, action } = getResourceAndAction(selectedTemplate);
        setResource(resource);
        setAction(action);
        try {
            const message = local
                ? await ApplyTemplateLocally(selectedTemplate, key)
                : await ApplyTemplate(selectedTemplate, key);
            if (message.startsWith('Error')) {
                setErrorMessage(message);
            }
            else {
                setSuccessMessage(message);
                // If we have an onComplete handler, show the continue button
                if (onComplete) {
                    setShowContinue(true);
                }
            }
        }
        catch (error) {
            setErrorMessage(error instanceof Error ? error.message : String(error));
        }
        finally {
            setIsLoading(false);
        }
    }, [local, key, onComplete]);
    // If a template is passed as a prop, apply it once
    useEffect(() => {
        if (template) {
            applyTemplate(template);
        }
    }, [template, applyTemplate]);
    // Handle user selection from SelectInput
    const handleSelect = async (item) => {
        setIsLoading(true);
        await applyTemplate(item.value);
    };
    return (React.createElement(Box, { flexDirection: "column" }, isLoading ? (React.createElement(Text, { color: "cyan" },
        React.createElement(Spinner, { type: "dots" }),
        " Applying template...")) : errorMessage && !onError ? (React.createElement(Text, { color: "red" }, errorMessage)) : successMessage ? (React.createElement(React.Fragment, null,
        React.createElement(Text, { color: "green" }, successMessage),
        showContinue && (React.createElement(Box, { marginTop: 1, flexDirection: 'column' },
            React.createElement(Text, null, "Press Enter to continue"),
            React.createElement(SelectInput, { items: [{ label: 'Continue', value: 'continue' }], onSelect: () => handleContinue() }))))) : !template ? (React.createElement(React.Fragment, null,
        React.createElement(Text, null, "Select Template "),
        React.createElement(SelectInput, { items: selectionValues, onSelect: handleSelect }))) : null));
}
