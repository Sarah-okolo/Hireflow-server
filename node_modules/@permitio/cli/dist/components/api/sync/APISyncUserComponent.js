import React, { useEffect, useState, useCallback } from 'react';
import TextInput from 'ink-text-input';
import { Box, Text } from 'ink';
import Spinner from 'ink-spinner';
import SelectInput from 'ink-select-input';
import { useAuth } from '../../AuthProvider.js';
import { useParseUserData } from '../../../hooks/useParseUserData.js';
import { useSyncUser } from '../../../hooks/useSyncUser.js';
import { useRolesApi } from '../../../hooks/useRolesApi.js';
export default function APISyncUserComponent({ options, onComplete, onError, }) {
    const { scope } = useAuth();
    // Parse user data using the hook
    const { payload, parseError } = useParseUserData(options);
    // Initialize user ID state - use key from options as the userId
    const [userId, setUserId] = useState(options.key || '');
    // Flag to track if the user ID is submitted
    const [userIdSubmitted, setUserIdSubmitted] = useState(!!options.key);
    // Component state to track workflow
    const [componentState, setComponentState] = useState(options.key ? 'roleSelection' : 'input');
    // Roles management
    const { getExistingRoles } = useRolesApi();
    const [availableRoles, setAvailableRoles] = useState([]);
    const [selectedRole, setSelectedRole] = useState('');
    const [rolesLoading, setRolesLoading] = useState(false);
    // Use the sync user hook
    const { status, errorMessage, syncUser, formatErrorMessage, setStatus, setErrorMessage, } = useSyncUser(scope.project_id, scope.environment_id, options.apiKey);
    // Handle parse errors
    useEffect(() => {
        if (parseError) {
            setErrorMessage(parseError);
            setComponentState('error');
            setStatus('error');
            return;
        }
        // Only process this effect if userId is submitted (not during typing)
        if (!userIdSubmitted) {
            return;
        }
        // If userIdSubmitted and we already have role assignments, proceed to processing
        if (userId &&
            payload.roleAssignments &&
            payload.roleAssignments.length > 0 &&
            payload.roleAssignments[0]) {
            const firstRole = payload.roleAssignments[0].role;
            setSelectedRole(firstRole);
            setStatus('processing');
            setComponentState('processing');
            syncUser(userId, payload);
        }
    }, [
        parseError,
        setErrorMessage,
        setStatus,
        payload,
        syncUser,
        userId,
        userIdSubmitted,
    ]);
    // Load available roles for assignment
    useEffect(() => {
        const fetchRoles = async () => {
            if (componentState === 'roleSelection') {
                try {
                    setRolesLoading(true);
                    const rolesSet = await getExistingRoles();
                    const rolesArray = Array.from(rolesSet);
                    if (rolesArray.length === 0) {
                        setErrorMessage('No roles available to assign');
                        setComponentState('error');
                        return;
                    }
                    setAvailableRoles(rolesArray);
                }
                catch (error) {
                    setErrorMessage(`Failed to fetch roles: ${error instanceof Error ? error.message : String(error)}`);
                    setComponentState('error');
                }
                finally {
                    setRolesLoading(false);
                }
            }
        };
        fetchRoles();
    }, [componentState, getExistingRoles, setErrorMessage]);
    // Handle sync status changes
    useEffect(() => {
        if (componentState === 'processing') {
            if (status === 'done') {
                if (onComplete) {
                    setComponentState('waitingForConfirmation');
                }
                else {
                    setComponentState('done');
                }
            }
            else if (status === 'error' && errorMessage) {
                setComponentState('error');
            }
        }
    }, [status, errorMessage, componentState, onComplete]);
    const handleUserIdSubmit = useCallback((value) => {
        if (value.trim() === '')
            return; // Prevent empty submission
        // Update payload key and mark as submitted
        setUserId(value);
        payload.key = value;
        setUserIdSubmitted(true);
        // Now move to role selection
        setComponentState('roleSelection');
    }, [payload]);
    const handleRoleSelect = useCallback((item) => {
        setSelectedRole(item.value);
        // Add role assignment to the payload
        payload.roleAssignments = [
            {
                role: item.value,
                tenant: 'default',
            },
        ];
        // Now proceed with the user sync with the updated payload
        setComponentState('processing');
        setStatus('processing');
        syncUser(userId, payload);
    }, [payload, syncUser, userId, setStatus]);
    // Handle continue button click from confirmation
    const handleContinue = useCallback(() => {
        if (componentState === 'waitingForConfirmation' && onComplete) {
            setComponentState('done');
            onComplete({
                userId: payload.key,
                firstName: payload.firstName,
                lastName: payload.lastName,
                email: payload.email,
                roles: selectedRole ? [selectedRole] : undefined,
            });
        }
        setComponentState('done');
    }, [componentState, onComplete, payload, selectedRole]);
    // Helper to extract roles from payload
    const getRolesToDisplay = useCallback(() => {
        if (selectedRole) {
            return [selectedRole];
        }
        if (payload.roleAssignments && payload.roleAssignments.length > 0) {
            return payload.roleAssignments.map(ra => ra.role).filter(Boolean);
        }
        return [];
    }, [selectedRole, payload.roleAssignments]);
    return (React.createElement(React.Fragment, null,
        componentState === 'roleSelection' && !rolesLoading && (React.createElement(Box, { flexDirection: "column", padding: 1 },
            React.createElement(Text, null,
                "Select a role to assign to user ",
                React.createElement(Text, { color: "green" }, userId),
                ":"),
            React.createElement(Box, { marginTop: 1, flexDirection: 'column' },
                React.createElement(SelectInput, { items: availableRoles.map(role => ({
                        label: role,
                        value: role,
                    })), onSelect: handleRoleSelect })))),
        componentState === 'roleSelection' && rolesLoading && (React.createElement(Box, null,
            React.createElement(Text, null,
                React.createElement(Spinner, { type: "dots" }),
                " Loading available roles..."))),
        componentState === 'processing' && (React.createElement(Box, null,
            React.createElement(Text, null,
                React.createElement(Spinner, { type: "dots" }),
                " Syncing user data with role assignment..."))),
        componentState === 'error' && errorMessage && !onError && (React.createElement(Text, { color: "red" },
            "Error: ",
            formatErrorMessage(errorMessage))),
        componentState === 'error' && errorMessage && onError && (React.createElement(Box, { flexDirection: "column" },
            React.createElement(Text, { color: "red" },
                "Error: ",
                formatErrorMessage(errorMessage)),
            React.createElement(Box, { marginTop: 1 },
                React.createElement(SelectInput, { items: [
                        {
                            label: 'Continue',
                            value: 'continue',
                        },
                    ], onSelect: () => {
                        onError(errorMessage);
                        setComponentState('done');
                    } })))),
        componentState === 'waitingForConfirmation' && (React.createElement(Box, { flexDirection: "column" },
            React.createElement(Text, { color: "green" }, "User Synced Successfully"),
            payload.key && React.createElement(Text, null,
                "User Key: ",
                payload.key),
            payload.firstName && React.createElement(Text, null,
                "Name: ",
                payload.firstName),
            payload.lastName && React.createElement(Text, null,
                "Last Name: ",
                payload.lastName),
            payload.email && React.createElement(Text, null,
                "Email: ",
                payload.email),
            getRolesToDisplay().length > 0 && (React.createElement(Text, null,
                "Assigned Role(s):",
                ' ',
                React.createElement(Text, { color: "blue" }, getRolesToDisplay().join(', ')))),
            Object.keys(payload?.attributes || {}).length > 0 && (React.createElement(Text, null,
                "Attributes: ",
                JSON.stringify(payload.attributes))),
            React.createElement(Box, { marginTop: 1 },
                React.createElement(SelectInput, { items: [
                        {
                            label: 'Continue',
                            value: 'continue',
                        },
                    ], onSelect: handleContinue })))),
        componentState === 'done' && (React.createElement(Box, { flexDirection: "column" },
            React.createElement(Text, { color: "green" }, "User Synced Successfully"),
            payload.key && React.createElement(Text, null,
                "User Key: ",
                payload.key),
            payload.firstName && React.createElement(Text, null,
                "Name: ",
                payload.firstName),
            payload.lastName && React.createElement(Text, null,
                "Last Name: ",
                payload.lastName),
            payload.email && React.createElement(Text, null,
                "Email: ",
                payload.email),
            getRolesToDisplay().length > 0 && (React.createElement(Text, null,
                "Assigned Role(s):",
                ' ',
                React.createElement(Text, { color: "blue" }, getRolesToDisplay().join(', ')))),
            Object.keys(payload?.attributes || {}).length > 0 && (React.createElement(Text, null,
                "Attributes: ",
                JSON.stringify(payload.attributes))))),
        componentState === 'input' && (React.createElement(React.Fragment, null,
            React.createElement(Text, { color: "yellow" }, "UserID is required. Please enter it:"),
            React.createElement(TextInput, { value: userId, onChange: setUserId, onSubmit: handleUserIdSubmit })))));
}
