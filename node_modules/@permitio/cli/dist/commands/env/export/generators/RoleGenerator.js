import Handlebars from 'handlebars';
import { readFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
// Define default global roles that should be excluded from creation
// These roles already exist in Permit by default
const DEFAULT_GLOBAL_ROLES = ['admin', 'editor', 'viewer'];
export class RoleGenerator {
    constructor(permit, warningCollector) {
        Object.defineProperty(this, "permit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: permit
        });
        Object.defineProperty(this, "warningCollector", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: warningCollector
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'roles'
        });
        Object.defineProperty(this, "template", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // This map will track the role key to terraform ID mapping
        Object.defineProperty(this, "roleIdMap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        // Track used terraform IDs to detect duplicates
        Object.defineProperty(this, "usedTerraformIds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Set()
        });
        // Map from role key to count of occurrences
        Object.defineProperty(this, "roleKeyCount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        // Resource map for dependency tracking
        Object.defineProperty(this, "resourceMap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        // Register Handlebars helpers
        this.registerHandlebarsHelpers();
        this.template = Handlebars.compile(readFileSync(join(__dirname, '../templates/role.hcl'), 'utf-8'));
    }
    // Register all Handlebars helpers
    registerHandlebarsHelpers() {
        Handlebars.registerHelper('json', function (context) {
            if (Array.isArray(context)) {
                return `[${context.map(item => `"${item}"`).join(', ')}]`;
            }
            return JSON.stringify(context);
        });
        // Helper to properly format an array of strings for Terraform
        Handlebars.registerHelper('permissionsArray', function (arr) {
            if (!arr || arr.length === 0)
                return '[]';
            return `[${arr.map(item => `"${item}"`).join(', ')}]`;
        });
        Handlebars.registerHelper('attributes', function (context) {
            if (!context)
                return '';
            const entries = Object.entries(context);
            if (entries.length === 0)
                return '';
            return `\n  attributes = {
    ${entries.map(([key, value]) => `${key} = ${JSON.stringify(value)}`).join('\n    ')}
  }`;
        });
    }
    // Method to get the role ID mapping
    getRoleIdMap() {
        return this.roleIdMap;
    }
    // Fetch data from Permit API
    async fetchPermitData() {
        try {
            const [rolesResponse, resourcesResponse] = await Promise.all([
                this.permit.api.roles.list(),
                this.permit.api.resources.list(),
            ]);
            // Prepare roles array and ensure it's valid
            const roles = Array.isArray(rolesResponse)
                ? rolesResponse
                : [];
            const resources = Array.isArray(resourcesResponse)
                ? resourcesResponse
                : [];
            return { roles, resources };
        }
        catch (error) {
            this.warningCollector.addWarning(`Failed to fetch data from Permit API: ${error}`);
            return { roles: [], resources: [] };
        }
    }
    // Count occurrences of role keys to identify potential duplicates
    countRoleKeyOccurrences(roles, resources) {
        this.roleKeyCount.clear();
        // Helper to increment the count for a key
        const countRoleKey = (key) => {
            this.roleKeyCount.set(key, (this.roleKeyCount.get(key) || 0) + 1);
        };
        // Count standalone roles
        for (const role of roles) {
            countRoleKey(role.key);
        }
        // Count resource roles
        for (const resource of resources) {
            if (!resource.roles || typeof resource.roles !== 'object')
                continue;
            Object.keys(resource.roles).forEach(roleKey => {
                countRoleKey(roleKey);
            });
        }
    }
    // Build a map of resource keys to resource objects for dependency tracking
    buildResourceMap(resources) {
        this.resourceMap.clear();
        resources.forEach(resource => {
            if (resource.key) {
                this.resourceMap.set(resource.key, resource);
            }
        });
    }
    // Generate Terraform ID for a role
    generateTerraformId(roleKey, resourceKey, isDuplicate = false) {
        let terraformId = roleKey;
        const isDefaultRole = DEFAULT_GLOBAL_ROLES.includes(roleKey);
        // For duplicate roles or default roles, use resource__role format
        if (isDuplicate || isDefaultRole || this.usedTerraformIds.has(roleKey)) {
            terraformId = resourceKey
                ? `${resourceKey}__${roleKey}`
                : `global_${roleKey}`;
        }
        // Track the terraform ID we're using
        this.usedTerraformIds.add(terraformId);
        return terraformId;
    }
    // Process resource-specific roles
    processResourceRoles(resources) {
        const resourceRoles = [];
        // Collect all resource roles
        for (const resource of resources) {
            const resourceKey = resource.key;
            if (!resourceKey)
                continue;
            if (!resource.roles || typeof resource.roles !== 'object') {
                continue;
            }
            Object.entries(resource.roles).forEach(([roleKey, roleData]) => {
                resourceRoles.push({
                    resourceKey,
                    roleKey,
                    roleData: roleData,
                });
            });
        }
        // Sort them by resource key for consistent output
        const sortedResourceRoles = resourceRoles.sort((a, b) => {
            return a.resourceKey.localeCompare(b.resourceKey);
        });
        // Process each resource role
        const validRoles = [];
        for (const { resourceKey, roleKey, roleData } of sortedResourceRoles) {
            // Check if this role key has duplicates
            const isDuplicate = (this.roleKeyCount.get(roleKey) ?? 0) > 1;
            // Generate Terraform ID
            const terraformId = this.generateTerraformId(roleKey, resourceKey, isDuplicate);
            // Map the role ID for future reference
            this.mapRoleId(resourceKey, roleKey, terraformId);
            // Extract permissions as strings only
            let permissions = [];
            if (roleData.permissions && Array.isArray(roleData.permissions)) {
                permissions = roleData.permissions.map((p) => String(p));
            }
            // All resource roles depend on their resource
            const dependencies = [`permitio_resource.${resourceKey}`];
            // Add the resource role
            validRoles.push({
                key: roleKey,
                terraformId,
                name: roleData.name || roleKey,
                resource: resourceKey,
                permissions,
                extends: roleData.extends?.map((e) => String(e)),
                dependencies,
                description: roleData.description,
                attributes: roleData.attributes,
            });
        }
        return validRoles;
    }
    // Handle mapping role IDs for both resource-specific and global roles
    mapRoleId(resourceKey, roleKey, terraformId) {
        if (resourceKey) {
            // Store the mapping for resource-specific role key
            this.roleIdMap.set(`${resourceKey}:${roleKey}`, terraformId);
            // Special handling for tenant:admin and board:admin cases
            if (resourceKey === 'tenant' && roleKey === 'admin') {
                this.roleIdMap.set('tenant:admin', 'tenant__admin');
            }
            else if (resourceKey === 'board' && roleKey === 'admin') {
                this.roleIdMap.set('board:admin', 'board__admin');
            }
        }
        // Only map the plain key if it's not a duplicate or already mapped
        const isDuplicate = (this.roleKeyCount.get(roleKey) ?? 0) > 1;
        if (!isDuplicate && !this.roleIdMap.has(roleKey)) {
            this.roleIdMap.set(roleKey, terraformId);
        }
    }
    // Process global (non-resource-specific) roles
    processGlobalRoles(roles) {
        const validRoles = [];
        for (const role of roles) {
            // Skip default global roles that already exist in the system
            if (DEFAULT_GLOBAL_ROLES.includes(role.key)) {
                // Still add to the ID map for role derivations
                this.roleIdMap.set(role.key, role.key);
                continue;
            }
            // Generate Terraform ID
            const terraformId = this.generateTerraformId(role.key);
            // Map the role ID
            this.mapRoleId(undefined, role.key, terraformId);
            // Build dependencies for resources mentioned in permissions
            const dependencies = this.buildResourceDependencies(role.permissions);
            validRoles.push({
                key: role.key,
                terraformId,
                name: role.name || role.key,
                description: role.description,
                permissions: (role.permissions || []).map((p) => String(p)),
                extends: (role.extends || []).map((e) => String(e)),
                attributes: role.attributes,
                dependencies,
            });
        }
        return validRoles;
    }
    // Build resource dependencies based on permissions
    buildResourceDependencies(permissions) {
        const dependencies = [];
        if (!permissions || !Array.isArray(permissions)) {
            return dependencies;
        }
        // For global roles, we need to ensure all resources referenced in permissions exist first
        permissions.forEach(perm => {
            // Check if permission has resource:action format
            const parts = typeof perm === 'string' ? perm.split(':') : [];
            if (parts.length === 2) {
                const resourceKey = parts[0];
                // Add resource as dependency if it exists
                if (resourceKey && this.resourceMap.has(resourceKey)) {
                    const depRef = `permitio_resource.${resourceKey}`;
                    if (!dependencies.includes(depRef)) {
                        dependencies.push(depRef);
                    }
                }
            }
        });
        return dependencies;
    }
    // Resolve role extension dependencies
    resolveRoleDependencies(roles) {
        for (const role of roles) {
            if (!role.extends || role.extends.length === 0)
                continue;
            // For each extended role, add a dependency
            for (const extendedRole of role.extends) {
                // If this is a resource role, we need to check for the resource-specific role key
                let extendedRoleTerraformId;
                if (role.resource) {
                    // First check if there's a resource-specific role with this key
                    const resourceSpecificKey = `${role.resource}:${extendedRole}`;
                    extendedRoleTerraformId = this.roleIdMap.get(resourceSpecificKey);
                }
                // If we didn't find a resource-specific role, check for standalone role
                if (!extendedRoleTerraformId) {
                    extendedRoleTerraformId = this.roleIdMap.get(extendedRole);
                }
                // If we found the role, add a dependency
                if (extendedRoleTerraformId) {
                    const ref = `permitio_role.${extendedRoleTerraformId}`;
                    if (!role.dependencies.includes(ref)) {
                        role.dependencies.push(ref);
                    }
                }
            }
        }
        return roles;
    }
    async generateHCL() {
        try {
            // Clear state maps and sets
            this.usedTerraformIds.clear();
            this.roleKeyCount.clear();
            this.resourceMap.clear();
            this.roleIdMap.clear();
            // Fetch data from Permit API
            const { roles, resources } = await this.fetchPermitData();
            // If no data, return empty string
            if (roles.length === 0 && resources.length === 0) {
                return '';
            }
            this.countRoleKeyOccurrences(roles, resources);
            this.buildResourceMap(resources);
            const resourceRoles = this.processResourceRoles(resources);
            const globalRoles = this.processGlobalRoles(roles);
            // Combine all roles
            const allRoles = [...resourceRoles, ...globalRoles];
            // Resolve role extension dependencies
            const rolesWithDependencies = this.resolveRoleDependencies(allRoles);
            // Render template with all processed roles
            return '\n# Roles\n' + this.template({ roles: rolesWithDependencies });
        }
        catch (error) {
            this.warningCollector.addWarning(`Failed to export roles: ${error}`);
            return '';
        }
    }
}
