import { createSafeId, fetchList } from '../utils.js';
import Handlebars from 'handlebars';
import { readFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
export class ResourceSetGenerator {
    constructor(permit, warningCollector) {
        Object.defineProperty(this, "permit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: permit
        });
        Object.defineProperty(this, "warningCollector", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: warningCollector
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'resource sets'
        });
        Object.defineProperty(this, "template", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resourceKeyMap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "resourceAttributes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        // Load and compile the template
        const templatePath = join(__dirname, '../templates/resource-set.hcl');
        try {
            const templateContent = readFileSync(templatePath, 'utf-8');
            this.template = Handlebars.compile(templateContent);
        }
        catch (error) {
            this.warningCollector.addWarning(`Failed to load resource set template: ${error}`);
            throw new Error(`Unable to load resource set template: ${error}`);
        }
    }
    async fetchResourceAttributes() {
        try {
            const resources = await fetchList(params => this.permit.api.resources.list(params), {});
            resources.forEach(resource => {
                // Skip the built-in user resource
                if (resource.key === '__user')
                    return;
                // Store resource ID to key mapping
                this.resourceKeyMap.set(resource.id.toString(), resource.key);
                // Store resource attributes
                if (resource.attributes) {
                    for (const [attrKey] of Object.entries(resource.attributes)) {
                        this.resourceAttributes.push({
                            resourceKey: resource.key,
                            attributeKey: attrKey,
                        });
                    }
                }
            });
        }
        catch (error) {
            this.warningCollector.addWarning(`Failed to fetch resource attributes: ${error}`);
        }
    }
    detectAdditionalDependencies() {
        return [];
    }
    async generateHCL() {
        try {
            // First fetch resource data to build maps
            await this.fetchResourceAttributes();
            const resourceSets = await fetchList(params => this.permit.api.conditionSets.list(params), {});
            const validSets = resourceSets
                .filter(set => set.type === 'resourceset' && set.resource_id)
                .map(set => {
                const resourceKey = this.resourceKeyMap.get(set.resource_id.toString()) ||
                    set.resource_id.toString();
                const conditions = set.conditions ??
                    {};
                // Start with resource dependency
                const dependencies = [`permitio_resource.${resourceKey}`];
                const additionalDeps = this.detectAdditionalDependencies();
                dependencies.push(...additionalDeps);
                return {
                    key: createSafeId(set.key),
                    name: set.name,
                    conditions: this.formatConditions(conditions),
                    resource: resourceKey,
                    depends_on: dependencies,
                };
            });
            if (validSets.length === 0) {
                return '';
            }
            const templateContext = { sets: validSets };
            const generated = this.template(templateContext);
            return '\n# Resource Sets\n' + generated;
        }
        catch (error) {
            this.warningCollector.addWarning(`Failed to export resource sets: ${error}`);
            return '';
        }
    }
    formatConditions(conditions) {
        try {
            if (typeof conditions === 'string') {
                try {
                    const parsed = JSON.parse(conditions);
                    return `jsonencode(${JSON.stringify(parsed, null, 2)})`;
                }
                catch {
                    return conditions;
                }
            }
            return `jsonencode(${JSON.stringify(conditions, null, 2)})`;
        }
        catch (error) {
            this.warningCollector.addWarning(`Failed to format conditions: ${error}. Using stringified version.`);
            return JSON.stringify(conditions);
        }
    }
}
