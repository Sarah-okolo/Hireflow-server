import { useCallback, useMemo } from 'react';
import useClient from './useClient.js';
/**
 * Hook for interacting with audit logs and PDP checking functionality
 */
export const useAuditLogs = () => {
    const { authenticatedApiClient, authenticatedPdpClient } = useClient();
    /**
     * Fetches audit logs based on filters with pagination support
     */
    const getAuditLogs = useCallback(async (filters) => {
        try {
            // Calculate date range
            const endDate = new Date();
            const startDate = new Date(endDate.getTime() - filters.timeFrame * 60 * 60 * 1000);
            const queryParams = {
                timestamp_from: Math.floor(startDate.getTime() / 1000),
                timestamp_to: Math.floor(endDate.getTime() / 1000),
                per_page: 100,
                sort_by: 'timestamp',
            };
            // Add optional filters
            if (filters.sourcePdp)
                queryParams['pdp_id'] = filters.sourcePdp;
            if (filters.users && filters.users.length > 0)
                queryParams['users'] = filters.users;
            if (filters.resources && filters.resources.length > 0)
                queryParams['resources'] = filters.resources;
            if (filters.tenant)
                queryParams['tenant'] = filters.tenant;
            if (filters.action)
                queryParams['action'] = filters.action;
            if (filters.decision !== undefined)
                queryParams['decision'] = filters.decision;
            // Start with page 1
            let currentPage = 1;
            let hasMorePages = true;
            const allLogs = [];
            const perPageValue = 100; // Store the per_page as a separate variable for comparison
            const maxLogsToFetch = filters.maxLogs || Number.MAX_SAFE_INTEGER; // Use maxLogs if provided
            // Fetch all pages
            while (hasMorePages && allLogs.length < maxLogsToFetch) {
                queryParams['page'] = currentPage;
                const { data, error } = await authenticatedApiClient().GET('/v2/pdps/{proj_id}/{env_id}/audit_logs', undefined, undefined, queryParams);
                if (error) {
                    return { data: null, error };
                }
                // Check if we have valid data
                if (!data || !Array.isArray(data.data)) {
                    return {
                        data: null,
                        error: 'Invalid response format for audit logs',
                    };
                }
                // Add logs from this page to our collection (up to maxLogs limit)
                const remainingCapacity = maxLogsToFetch - allLogs.length;
                const logsToAdd = data.data.slice(0, remainingCapacity);
                allLogs.push(...logsToAdd);
                // Check if we've reached the last page or hit our limit
                if (data.data.length < perPageValue ||
                    allLogs.length >= maxLogsToFetch) {
                    hasMorePages = false;
                }
                else {
                    currentPage++;
                }
            }
            return {
                data: { data: allLogs },
                error: null,
            };
        }
        catch (err) {
            return {
                data: null,
                error: err instanceof Error ? err.message : String(err),
            };
        }
    }, [authenticatedApiClient]);
    /**
     * Fetches detailed information for a specific audit log ID
     */
    const getAuditLogDetails = useCallback(async (auditLogId) => {
        try {
            // Directly fetch a specific audit log by ID
            const { data, error } = await authenticatedApiClient().GET('/v2/pdps/{proj_id}/{env_id}/audit_logs/{log_id}', { log_id: auditLogId });
            if (error) {
                return { data: null, error };
            }
            return { data, error: null };
        }
        catch (err) {
            return {
                data: null,
                error: err instanceof Error ? err.message : String(err),
            };
        }
    }, [authenticatedApiClient]);
    /**
     * Performs an authorization check against a PDP
     */
    const checkPdpPermission = useCallback(async (request, pdpUrl) => {
        try {
            // Format the request according to PDP v2 API expectations
            const pdpRequest = {
                tenant: request.tenant,
                action: request.action,
                user: {
                    key: request.user.key,
                    firstName: undefined,
                    lastName: undefined,
                    email: undefined,
                    attributes: {},
                },
                resource: {
                    type: request.resource.type,
                    key: request.resource.key || '',
                    tenant: request.tenant,
                    attributes: {},
                    context: {},
                },
                context: {},
            };
            const { data, error } = await authenticatedPdpClient(pdpUrl).POST('/allowed', undefined, pdpRequest);
            if (error) {
                return {
                    data: null,
                    error: `PDP check failed: ${error}`,
                };
            }
            return { data, error: null };
        }
        catch (err) {
            return {
                data: null,
                error: err instanceof Error ? err.message : String(err),
            };
        }
    }, [authenticatedPdpClient]);
    return useMemo(() => ({
        getAuditLogs,
        getAuditLogDetails,
        checkPdpPermission,
    }), [getAuditLogs, getAuditLogDetails, checkPdpPermission]);
};
export default useAuditLogs;
