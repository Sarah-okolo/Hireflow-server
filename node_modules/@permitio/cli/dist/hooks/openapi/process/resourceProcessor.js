import { sanitizeKey, isDuplicateError, HTTP_METHODS, } from '../../../utils/openapiUtils.js';
import { ERROR_CREATING_RESOURCE, PERMIT_EXTENSIONS, } from './openapiConstants.js';
// Define the processActions function implementation
const processActions = async (pathItem, resource, context, createAction) => {
    const { actions, errors } = context;
    for (const method of HTTP_METHODS) {
        const operation = pathItem[method];
        if (!operation)
            continue;
        // Get action from x-permit-action or default to HTTP method
        const action = operation[PERMIT_EXTENSIONS.ACTION] || method;
        // Create action if needed
        const resourceActions = actions.get(resource);
        if (resourceActions && !resourceActions.has(action)) {
            try {
                const result = await createAction(resource, action, action);
                if (result.error) {
                    if (!isDuplicateError(result.error)) {
                        errors.push(`Failed to create action ${action}: ${JSON.stringify(result.error)}`);
                    }
                }
                resourceActions.add(action);
            }
            catch (actionError) {
                errors.push(`Error creating action ${action}: ${actionError}`);
            }
        }
    }
};
export async function processResources(context, pathItems, createResource, updateResource, createAction) {
    const { resources, actions, errors, warnings, existingResources } = context;
    for (const [, pathItem] of Object.entries(pathItems || {})) {
        if (!pathItem || typeof pathItem !== 'object')
            continue;
        const typedPathItem = pathItem;
        const rawResource = typedPathItem[PERMIT_EXTENSIONS.RESOURCE];
        if (!rawResource)
            continue;
        // Sanitize resource key
        const resource = sanitizeKey(rawResource);
        // Create or update resource
        if (!resources.has(resource)) {
            // Check if resource already exists
            const resourceExists = existingResources.some(r => r.key === resource);
            if (!resourceExists) {
                try {
                    const result = await createResource(resource, rawResource);
                    if (result.error) {
                        if (!isDuplicateError(result.error)) {
                            errors.push(`${ERROR_CREATING_RESOURCE} ${resource}: ${JSON.stringify(result.error)}`);
                        }
                        else {
                            await updateResource(resource, rawResource);
                        }
                    }
                }
                catch (resourceError) {
                    errors.push(`Error creating resource ${resource}: ${resourceError}`);
                }
            }
            else {
                try {
                    await updateResource(resource, rawResource);
                }
                catch (updateError) {
                    warnings.push(`Error updating resource ${resource}: ${updateError}`);
                }
            }
            resources.add(resource);
            actions.set(resource, new Set());
        }
        // Process actions for this resource
        await processActions(typedPathItem, resource, context, createAction);
    }
    return context;
}
