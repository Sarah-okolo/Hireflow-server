import { sanitizeKey, isDuplicateError, HTTP_METHODS, } from '../../../utils/openapiUtils.js';
import { ERROR_CREATING_ROLE, ERROR_UPDATING_ROLE, ERROR_CREATING_RESOURCE_ROLE, PERMIT_EXTENSIONS, } from './openapiConstants.js';
// Define updateExistingRole function before it's used
async function updateExistingRole(role, permissionStr, context, getRole, updateRole) {
    const { warnings } = context;
    try {
        // Get existing role to preserve permissions
        const { data: roleObject } = await getRole(role);
        // Access permissions safely from the role object
        const existingPermissions = roleObject?.permissions || [];
        let permissions = Array.isArray(existingPermissions)
            ? existingPermissions
            : [];
        if (permissionStr && !permissions.includes(permissionStr)) {
            permissions = [...permissions, permissionStr];
        }
        // Update the role with the new permissions
        const updateResult = await updateRole(role, role, permissions);
        if (updateResult.error) {
            warnings.push(`${ERROR_UPDATING_ROLE} ${role}: ${JSON.stringify(updateResult.error)}`);
        }
    }
    catch (getRoleError) {
        warnings.push(`Failed to get role details for ${role}: ${getRoleError}`);
    }
}
export async function processRoles(context, pathItems, getRole, createRole, updateRole) {
    const { roles, existingRoles, errors, warnings } = context;
    for (const [, pathItem] of Object.entries(pathItems || {})) {
        if (!pathItem || typeof pathItem !== 'object')
            continue;
        const typedPathItem = pathItem;
        // Process HTTP methods for roles
        for (const method of HTTP_METHODS) {
            const operation = typedPathItem[method];
            if (!operation)
                continue;
            // Create/update role if specified and not already processed
            const role = operation[PERMIT_EXTENSIONS.ROLE];
            if (role && !roles.has(role)) {
                // Check if role already exists
                const roleExists = existingRoles.some(r => r.key === role);
                // Get the operation's resource and action for permissions
                const resource = sanitizeKey(typedPathItem[PERMIT_EXTENSIONS.RESOURCE] || '');
                const action = operation[PERMIT_EXTENSIONS.ACTION] || method;
                // Create permission string if resource and action exist
                const permissionStr = resource && action ? `${resource}:${action}` : undefined;
                if (!roleExists) {
                    try {
                        const result = await createRole(role, role);
                        if (result.error) {
                            if (!isDuplicateError(result.error)) {
                                errors.push(`${ERROR_CREATING_ROLE} ${role}: ${JSON.stringify(result.error)}`);
                            }
                            else {
                                // Role exists but wasn't in our list, try to update it
                                await updateExistingRole(role, permissionStr, context, getRole, updateRole);
                            }
                        }
                        else {
                            // If we have a permission to add, update the role with it
                            if (permissionStr) {
                                try {
                                    await updateRole(role, role, [
                                        permissionStr,
                                    ]);
                                }
                                catch (updateError) {
                                    warnings.push(`Failed to add permission to role ${role}: ${updateError}`);
                                }
                            }
                        }
                    }
                    catch (roleError) {
                        errors.push(`Error creating role ${role}: ${roleError}`);
                    }
                }
                else {
                    await updateExistingRole(role, permissionStr, context, getRole, updateRole);
                }
                roles.add(role);
            }
        }
    }
    return context;
}
export async function processResourceRoles(context, pathItems, createResourceRole) {
    const { resourceRoles, errors, warnings } = context;
    for (const [, pathItem] of Object.entries(pathItems || {})) {
        if (!pathItem || typeof pathItem !== 'object')
            continue;
        const typedPathItem = pathItem;
        const rawResource = typedPathItem[PERMIT_EXTENSIONS.RESOURCE];
        if (!rawResource)
            continue;
        const resource = sanitizeKey(rawResource);
        // Process HTTP methods
        for (const method of HTTP_METHODS) {
            const operation = typedPathItem[method];
            if (!operation)
                continue;
            // Process resource roles
            const resourceRole = operation[PERMIT_EXTENSIONS.RESOURCE_ROLE];
            if (resourceRole) {
                const sanitizedResourceRole = `${resource}_${resourceRole}`;
                if (!resourceRoles.has(sanitizedResourceRole)) {
                    try {
                        // Create individual permission for specific action instead of wildcard
                        const action = operation[PERMIT_EXTENSIONS.ACTION] || method;
                        const permissionString = `${resource}:${action}`;
                        const result = await createResourceRole(resource, sanitizedResourceRole, `${rawResource} ${resourceRole}`, permissionString);
                        if (result.error) {
                            if (!isDuplicateError(result.error)) {
                                errors.push(`${ERROR_CREATING_RESOURCE_ROLE} ${resourceRole}: ${JSON.stringify(result.error)}`);
                            }
                            else {
                                warnings.push(`Resource role ${sanitizedResourceRole} already exists, skipping creation`);
                            }
                        }
                        resourceRoles.set(sanitizedResourceRole, true);
                    }
                    catch (resourceRoleError) {
                        errors.push(`Error creating resource role ${resourceRole}: ${resourceRoleError}`);
                    }
                }
            }
        }
    }
    return context;
}
