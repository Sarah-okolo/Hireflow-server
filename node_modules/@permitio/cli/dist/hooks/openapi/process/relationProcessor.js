import { sanitizeKey, isDuplicateError, HTTP_METHODS, } from '../../../utils/openapiUtils.js';
import { PERMIT_EXTENSIONS } from './openapiConstants.js';
export async function processRelations(context, pathItems, createResource, createRelation, setProgress) {
    const { resources, relations, errors, warnings } = context;
    for (const [, pathItem] of Object.entries(pathItems || {})) {
        if (!pathItem || typeof pathItem !== 'object')
            continue;
        const typedPathItem = pathItem;
        const rawResource = typedPathItem[PERMIT_EXTENSIONS.RESOURCE];
        if (!rawResource)
            continue;
        // Process HTTP methods
        for (const method of HTTP_METHODS) {
            const operation = typedPathItem[method];
            if (!operation)
                continue;
            // Process relation
            const relation = operation[PERMIT_EXTENSIONS.RELATION];
            if (relation && typeof relation === 'object') {
                try {
                    const relationData = relation;
                    const sanitizedRelation = {
                        subject_resource: sanitizeKey(relationData.subject_resource),
                        object_resource: sanitizeKey(relationData.object_resource),
                        key: relationData.key ||
                            `${sanitizeKey(relationData.subject_resource)}_${sanitizeKey(relationData.object_resource)}`,
                        name: relationData.name ||
                            `${relationData.subject_resource} to ${relationData.object_resource}`,
                    };
                    // First, check if both resources exist, create if they don't
                    if (!resources.has(sanitizedRelation.subject_resource)) {
                        await createResource(sanitizedRelation.subject_resource, relationData.subject_resource);
                        resources.add(sanitizedRelation.subject_resource);
                    }
                    if (!resources.has(sanitizedRelation.object_resource)) {
                        await createResource(sanitizedRelation.object_resource, relationData.object_resource);
                        resources.add(sanitizedRelation.object_resource);
                    }
                    setProgress(`Creating relation between ${sanitizedRelation.subject_resource} and ${sanitizedRelation.object_resource}...`);
                    // Add a small delay to allow resources to be registered
                    await new Promise(resolve => setTimeout(resolve, 300));
                    // Create the relation
                    const relationResult = await createRelation(sanitizedRelation);
                    if (relationResult.error) {
                        if (!isDuplicateError(relationResult.error)) {
                            errors.push(`Failed to create relation: ${JSON.stringify(relationResult.error)}`);
                        }
                        else {
                            warnings.push(`Relation already exists, skipping creation`);
                        }
                    }
                    // Store the relation for use in role derivation
                    relations.set(sanitizedRelation.key, JSON.stringify(sanitizedRelation));
                }
                catch (relationError) {
                    errors.push(`Error creating relation: ${relationError}`);
                }
            }
        }
    }
    return context;
}
export async function processDerivedRoles(context, pathItems, createDerivedRole) {
    const { warnings } = context;
    for (const [, pathItem] of Object.entries(pathItems || {})) {
        if (!pathItem || typeof pathItem !== 'object')
            continue;
        const typedPathItem = pathItem;
        // Process HTTP methods
        for (const method of HTTP_METHODS) {
            const operation = typedPathItem[method];
            if (!operation)
                continue;
            // Process derived role
            const derivedRole = operation[PERMIT_EXTENSIONS.DERIVED_ROLE];
            if (derivedRole && typeof derivedRole === 'object') {
                try {
                    const derivedRoleData = derivedRole;
                    // Use the resource from the path if not specified
                    const resourceKey = sanitizeKey(derivedRoleData.resource ||
                        typedPathItem[PERMIT_EXTENSIONS.RESOURCE] ||
                        '');
                    try {
                        // Create the derived role
                        const derivedRoleRequest = {
                            ...derivedRoleData,
                            resource: resourceKey,
                        };
                        const derivedRoleResult = await createDerivedRole(derivedRoleRequest);
                        if (derivedRoleResult.error) {
                            warnings.push(`Could not create role derivation automatically: ${JSON.stringify(derivedRoleResult.error)}`);
                        }
                    }
                    catch (innerError) {
                        warnings.push(`Could not create role derivation automatically: ${innerError}`);
                    }
                }
                catch (derivedRoleError) {
                    warnings.push(`Could not set up role derivation: ${derivedRoleError}`);
                }
            }
        }
    }
    return context;
}
