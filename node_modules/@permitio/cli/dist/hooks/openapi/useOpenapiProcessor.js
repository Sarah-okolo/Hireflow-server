import { useCallback } from 'react';
import path from 'node:path';
import SwaggerParser from '@apidevtools/swagger-parser';
import { useOpenapiApi } from './useOpenapiApi.js';
import { processResources, processRoles, processResourceRoles, processRelations, processDerivedRoles, generateUrlMappings, createMappings, } from './process/openapiProcessorExports.js';
/**
 * Hook that contains the OpenAPI processing logic
 */
export const useOpenapiProcessor = ({ inputPath, setProgress, setStatus, setError, setProcessingDone, }) => {
    // Import all API hooks through the main API hook
    const { listResources, createResource, updateResource, createAction, listRoles, getRole, createRole, updateRole, createResourceRole, createRelation, createDerivedRole, deleteUrlMappings, createUrlMappings, } = useOpenapiApi();
    // Process the OpenAPI spec file
    const processSpec = useCallback(async () => {
        try {
            // Normalize the path
            const normalizedPath = inputPath.startsWith('http')
                ? inputPath
                : path.resolve(process.cwd(), inputPath);
            setProgress('Loading and validating OpenAPI spec...');
            // Use swagger-parser to parse and validate the spec
            let parsedSpec;
            try {
                // Parse and validate the OpenAPI spec
                parsedSpec = (await SwaggerParser.validate(normalizedPath));
            }
            catch (parseError) {
                throw new Error(`Failed to parse or validate OpenAPI spec: ${parseError instanceof Error ? parseError.message : String(parseError)}`);
            }
            // Get the base URL from the servers section if available
            const baseUrl = parsedSpec.servers &&
                parsedSpec.servers.length > 0 &&
                parsedSpec.servers[0] !== undefined
                ? parsedSpec.servers[0].url
                : '';
            // Create context for processing
            const context = {
                resources: new Set(),
                actions: new Map(),
                roles: new Set(),
                resourceRoles: new Map(),
                relations: new Map(),
                mappings: [],
                errors: [],
                warnings: [],
                existingResources: [],
                existingRoles: [],
                baseUrl,
            };
            // List existing resources and roles to avoid conflicts
            try {
                const { data: resourcesArray } = (await listResources());
                if (resourcesArray) {
                    context.existingResources = resourcesArray;
                }
            }
            catch {
                // Continue with empty resources array if fetching fails
            }
            try {
                const { data: rolesArray } = (await listRoles());
                if (rolesArray) {
                    context.existingRoles = rolesArray;
                }
            }
            catch {
                // Continue with empty roles array if fetching fails
            }
            // Process each stage in sequence
            setProgress('Processing OpenAPI extensions...');
            await processResources(context, parsedSpec.paths || {}, createResource, updateResource, createAction);
            setProgress('Creating roles and permissions...');
            await processRoles(context, parsedSpec.paths || {}, getRole, createRole, updateRole);
            setProgress('Creating relations between resources...');
            await processRelations(context, parsedSpec.paths || {}, createResource, createRelation, setProgress);
            setProgress('Creating role derivations and resource-specific roles...');
            await processResourceRoles(context, parsedSpec.paths || {}, createResourceRole);
            await processDerivedRoles(context, parsedSpec.paths || {}, createDerivedRole);
            await generateUrlMappings(context, parsedSpec.paths || {});
            setProgress('Creating URL mappings...');
            await createMappings(context, ((source) => deleteUrlMappings(source)), ((mappings, authType, tokenHeader) => {
                // Convert the UrlMappingRequest[] to MappingRule[]
                const adaptedMappings = mappings.map(mapping => {
                    // Normalize http_method to ensure it matches the allowed values
                    const httpMethod = mapping.http_method.toLowerCase();
                    // Validate http_method is one of the allowed values
                    if (![
                        'get',
                        'put',
                        'post',
                        'delete',
                        'options',
                        'head',
                        'patch',
                    ].includes(httpMethod)) {
                        throw new Error(`Invalid HTTP method: ${mapping.http_method}. Must be one of: get, put, post, delete, options, head, patch`);
                    }
                    // Create properly typed object
                    const result = {
                        url: mapping.url,
                        http_method: httpMethod,
                        resource: mapping.resource,
                        headers: {}, // Empty headers object as required by API
                    };
                    // Add optional properties if they exist
                    if (mapping.action)
                        result.action = mapping.action;
                    // Only set url_type if the source mapping has a urlType property
                    // AND it's specifically the value "regex"
                    if ('urlType' in mapping && mapping.urlType === 'regex') {
                        result.url_type = 'regex';
                    }
                    return result;
                });
                return createUrlMappings(adaptedMappings, authType, tokenHeader);
            }));
            // Check if there were any errors
            if (context.errors.length > 0) {
                setError(`Completed with ${context.errors.length} errors. Last error: ${context.errors[context.errors.length - 1]}`);
                setStatus('error');
            }
            else {
                setStatus('success');
            }
            setProcessingDone(true);
        }
        catch (err) {
            setError(err instanceof Error ? err.message : String(err));
            setStatus('error');
            setProcessingDone(true);
        }
    }, [
        inputPath,
        setProgress,
        setError,
        setStatus,
        setProcessingDone,
        createAction,
        createDerivedRole,
        createRelation,
        createResource,
        createResourceRole,
        createRole,
        createUrlMappings,
        deleteUrlMappings,
        getRole,
        listResources,
        listRoles,
        updateResource,
        updateRole,
    ]);
    return { processSpec };
};
